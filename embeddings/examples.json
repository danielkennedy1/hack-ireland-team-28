[
  {
    "title": "three.js webgl - animation - keyframes",
    "tags": [
      "threejs",
      "webgl",
      "animation",
      "keyframes"
    ],
    "description": "Example of three.js webgl - animation - keyframes",
    "code": "import * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\n\t\t\tlet mixer;\n\n\t\t\tconst clock = new THREE.Clock();\n\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\tconst stats = new Stats();\n\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\tconst renderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\tconst scene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0xbfe3dd );\n\t\t\tscene.environment = pmremGenerator.fromScene( new RoomEnvironment(), 0.04 ).texture;\n\n\t\t\tconst camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\tcamera.position.set( 5, 2, 8 );\n\n\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.target.set( 0, 0.5, 0 );\n\t\t\tcontrols.update();\n\t\t\tcontrols.enablePan = false;\n\t\t\tcontrols.enableDamping = true;\n\n\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );\n\n\t\t\tconst loader = new GLTFLoader();\n\t\t\tloader.setDRACOLoader( dracoLoader );\n\t\t\tloader.load( 'models/gltf/LittlestTokyo.glb', function ( gltf ) {\n\n\t\t\t\tconst model = gltf.scene;\n\t\t\t\tmodel.position.set( 1, 1, 0 );\n\t\t\t\tmodel.scale.set( 0.01, 0.01, 0.01 );\n\t\t\t\tscene.add( model );\n\n\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\t\t\t\tmixer.clipAction( gltf.animations[ 0 ] ).play();\n\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t}, undefined, function ( e ) {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t} );\n\n\n\t\t\twindow.onresize = function () {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t};\n\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tmixer.update( delta );\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tstats.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}"
  },
  {
    "title": "three.js webgl - animation - skinning",
    "tags": [
      "threejs",
      "webgl",
      "animation",
      "skinning"
    ],
    "description": "Example of three.js webgl - animation - skinning",
    "code": "import * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet scene, renderer, camera, stats;\n\t\t\tlet model, skeleton, mixer, clock;\n\n\t\t\tconst crossFadeControls = [];\n\n\t\t\tlet idleAction, walkAction, runAction;\n\t\t\tlet idleWeight, walkWeight, runWeight;\n\t\t\tlet actions, settings;\n\n\t\t\tlet singleStepMode = false;\n\t\t\tlet sizeOfNextStep = 0;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\t\tcamera.position.set( 1, 2, - 3 );\n\t\t\t\tcamera.lookAt( 0, 1, 0 );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xa0a0a0 );\n\t\t\t\tscene.fog = new THREE.Fog( 0xa0a0a0, 10, 50 );\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 3 );\n\t\t\t\themiLight.position.set( 0, 20, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( - 3, 10, - 10 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.top = 2;\n\t\t\t\tdirLight.shadow.camera.bottom = - 2;\n\t\t\t\tdirLight.shadow.camera.left = - 2;\n\t\t\t\tdirLight.shadow.camera.right = 2;\n\t\t\t\tdirLight.shadow.camera.near = 0.1;\n\t\t\t\tdirLight.shadow.camera.far = 40;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );\n\n\t\t\t\t// ground\n\n\t\t\t\tconst mesh = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100 ), new THREE.MeshPhongMaterial( { color: 0xcbcbcb, depthWrite: false } ) );\n\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Soldier.glb', function ( gltf ) {\n\n\t\t\t\t\tmodel = gltf.scene;\n\t\t\t\t\tscene.add( model );\n\n\t\t\t\t\tmodel.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.isMesh ) object.castShadow = true;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tskeleton = new THREE.SkeletonHelper( model );\n\t\t\t\t\tskeleton.visible = false;\n\t\t\t\t\tscene.add( skeleton );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tcreatePanel();\n\n\n\t\t\t\t\t//\n\n\t\t\t\t\tconst animations = gltf.animations;\n\n\t\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\n\t\t\t\t\tidleAction = mixer.clipAction( animations[ 0 ] );\n\t\t\t\t\twalkAction = mixer.clipAction( animations[ 3 ] );\n\t\t\t\t\trunAction = mixer.clipAction( animations[ 1 ] );\n\n\t\t\t\t\tactions = [ idleAction, walkAction, runAction ];\n\n\t\t\t\t\tactivateAllActions();\n\n\t\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction createPanel() {\n\n\t\t\t\tconst panel = new GUI( { width: 310 } );\n\n\t\t\t\tconst folder1 = panel.addFolder( 'Visibility' );\n\t\t\t\tconst folder2 = panel.addFolder( 'Activation/Deactivation' );\n\t\t\t\tconst folder3 = panel.addFolder( 'Pausing/Stepping' );\n\t\t\t\tconst folder4 = panel.addFolder( 'Crossfading' );\n\t\t\t\tconst folder5 = panel.addFolder( 'Blend Weights' );\n\t\t\t\tconst folder6 = panel.addFolder( 'General Speed' );\n\n\t\t\t\tsettings = {\n\t\t\t\t\t'show model': true,\n\t\t\t\t\t'show skeleton': false,\n\t\t\t\t\t'deactivate all': deactivateAllActions,\n\t\t\t\t\t'activate all': activateAllActions,\n\t\t\t\t\t'pause/continue': pauseContinue,\n\t\t\t\t\t'make single step': toSingleStepMode,\n\t\t\t\t\t'modify step size': 0.05,\n\t\t\t\t\t'from walk to idle': function () {\n\n\t\t\t\t\t\tprepareCrossFade( walkAction, idleAction, 1.0 );\n\n\t\t\t\t\t},\n\t\t\t\t\t'from idle to walk': function () {\n\n\t\t\t\t\t\tprepareCrossFade( idleAction, walkAction, 0.5 );\n\n\t\t\t\t\t},\n\t\t\t\t\t'from walk to run': function () {\n\n\t\t\t\t\t\tprepareCrossFade( walkAction, runAction, 2.5 );\n\n\t\t\t\t\t},\n\t\t\t\t\t'from run to walk': function () {\n\n\t\t\t\t\t\tprepareCrossFade( runAction, walkAction, 5.0 );\n\n\t\t\t\t\t},\n\t\t\t\t\t'use default duration': true,\n\t\t\t\t\t'set custom duration': 3.5,\n\t\t\t\t\t'modify idle weight': 0.0,\n\t\t\t\t\t'modify walk weight': 1.0,\n\t\t\t\t\t'modify run weight': 0.0,\n\t\t\t\t\t'modify time scale': 1.0\n\t\t\t\t};\n\n\t\t\t\tfolder1.add( settings, 'show model' ).onChange( showModel );\n\t\t\t\tfolder1.add( settings, 'show skeleton' ).onChange( showSkeleton );\n\t\t\t\tfolder2.add( settings, 'deactivate all' );\n\t\t\t\tfolder2.add( settings, 'activate all' );\n\t\t\t\tfolder3.add( settings, 'pause/continue' );\n\t\t\t\tfolder3.add( settings, 'make single step' );\n\t\t\t\tfolder3.add( settings, 'modify step size', 0.01, 0.1, 0.001 );\n\t\t\t\tcrossFadeControls.push( folder4.add( settings, 'from walk to idle' ) );\n\t\t\t\tcrossFadeControls.push( folder4.add( settings, 'from idle to walk' ) );\n\t\t\t\tcrossFadeControls.push( folder4.add( settings, 'from walk to run' ) );\n\t\t\t\tcrossFadeControls.push( folder4.add( settings, 'from run to walk' ) );\n\t\t\t\tfolder4.add( settings, 'use default duration' );\n\t\t\t\tfolder4.add( settings, 'set custom duration', 0, 10, 0.01 );\n\t\t\t\tfolder5.add( settings, 'modify idle weight', 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {\n\n\t\t\t\t\tsetWeight( idleAction, weight );\n\n\t\t\t\t} );\n\t\t\t\tfolder5.add( settings, 'modify walk weight', 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {\n\n\t\t\t\t\tsetWeight( walkAction, weight );\n\n\t\t\t\t} );\n\t\t\t\tfolder5.add( settings, 'modify run weight', 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {\n\n\t\t\t\t\tsetWeight( runAction, weight );\n\n\t\t\t\t} );\n\t\t\t\tfolder6.add( settings, 'modify time scale', 0.0, 1.5, 0.01 ).onChange( modifyTimeScale );\n\n\t\t\t\tfolder1.open();\n\t\t\t\tfolder2.open();\n\t\t\t\tfolder3.open();\n\t\t\t\tfolder4.open();\n\t\t\t\tfolder5.open();\n\t\t\t\tfolder6.open();\n\n\t\t\t}\n\n\n\t\t\tfunction showModel( visibility ) {\n\n\t\t\t\tmodel.visible = visibility;\n\n\t\t\t}\n\n\n\t\t\tfunction showSkeleton( visibility ) {\n\n\t\t\t\tskeleton.visible = visibility;\n\n\t\t\t}\n\n\n\t\t\tfunction modifyTimeScale( speed ) {\n\n\t\t\t\tmixer.timeScale = speed;\n\n\t\t\t}\n\n\n\t\t\tfunction deactivateAllActions() {\n\n\t\t\t\tactions.forEach( function ( action ) {\n\n\t\t\t\t\taction.stop();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction activateAllActions() {\n\n\t\t\t\tsetWeight( idleAction, settings[ 'modify idle weight' ] );\n\t\t\t\tsetWeight( walkAction, settings[ 'modify walk weight' ] );\n\t\t\t\tsetWeight( runAction, settings[ 'modify run weight' ] );\n\n\t\t\t\tactions.forEach( function ( action ) {\n\n\t\t\t\t\taction.play();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction pauseContinue() {\n\n\t\t\t\tif ( singleStepMode ) {\n\n\t\t\t\t\tsingleStepMode = false;\n\t\t\t\t\tunPauseAllActions();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( idleAction.paused ) {\n\n\t\t\t\t\t\tunPauseAllActions();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpauseAllActions();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction pauseAllActions() {\n\n\t\t\t\tactions.forEach( function ( action ) {\n\n\t\t\t\t\taction.paused = true;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction unPauseAllActions() {\n\n\t\t\t\tactions.forEach( function ( action ) {\n\n\t\t\t\t\taction.paused = false;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction toSingleStepMode() {\n\n\t\t\t\tunPauseAllActions();\n\n\t\t\t\tsingleStepMode = true;\n\t\t\t\tsizeOfNextStep = settings[ 'modify step size' ];\n\n\t\t\t}\n\n\t\t\tfunction prepareCrossFade( startAction, endAction, defaultDuration ) {\n\n\t\t\t\t// Switch default / custom crossfade duration (according to the user's choice)\n\n\t\t\t\tconst duration = setCrossFadeDuration( defaultDuration );\n\n\t\t\t\t// Make sure that we don't go on in singleStepMode, and that all actions are unpaused\n\n\t\t\t\tsingleStepMode = false;\n\t\t\t\tunPauseAllActions();\n\n\t\t\t\t// If the current action is 'idle' (duration 4 sec), execute the crossfade immediately;\n\t\t\t\t// else wait until the current action has finished its current loop\n\n\t\t\t\tif ( startAction === idleAction ) {\n\n\t\t\t\t\texecuteCrossFade( startAction, endAction, duration );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsynchronizeCrossFade( startAction, endAction, duration );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction setCrossFadeDuration( defaultDuration ) {\n\n\t\t\t\t// Switch default crossfade duration <-> custom crossfade duration\n\n\t\t\t\tif ( settings[ 'use default duration' ] ) {\n\n\t\t\t\t\treturn defaultDuration;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn settings[ 'set custom duration' ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction synchronizeCrossFade( startAction, endAction, duration ) {\n\n\t\t\t\tmixer.addEventListener( 'loop', onLoopFinished );\n\n\t\t\t\tfunction onLoopFinished( event ) {\n\n\t\t\t\t\tif ( event.action === startAction ) {\n\n\t\t\t\t\t\tmixer.removeEventListener( 'loop', onLoopFinished );\n\n\t\t\t\t\t\texecuteCrossFade( startAction, endAction, duration );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction executeCrossFade( startAction, endAction, duration ) {\n\n\t\t\t\t// Not only the start action, but also the end action must get a weight of 1 before fading\n\t\t\t\t// (concerning the start action this is already guaranteed in this place)\n\n\t\t\t\tsetWeight( endAction, 1 );\n\t\t\t\tendAction.time = 0;\n\n\t\t\t\t// Crossfade with warping - you can also try without warping by setting the third parameter to false\n\n\t\t\t\tstartAction.crossFadeTo( endAction, duration, true );\n\n\t\t\t}\n\n\t\t\t// This function is needed, since animationAction.crossFadeTo() disables its start action and sets\n\t\t\t// the start action's timeScale to ((start animation's duration) / (end animation's duration))\n\n\t\t\tfunction setWeight( action, weight ) {\n\n\t\t\t\taction.enabled = true;\n\t\t\t\taction.setEffectiveTimeScale( 1 );\n\t\t\t\taction.setEffectiveWeight( weight );\n\n\t\t\t}\n\n\t\t\t// Called by the render loop\n\n\t\t\tfunction updateWeightSliders() {\n\n\t\t\t\tsettings[ 'modify idle weight' ] = idleWeight;\n\t\t\t\tsettings[ 'modify walk weight' ] = walkWeight;\n\t\t\t\tsettings[ 'modify run weight' ] = runWeight;\n\n\t\t\t}\n\n\t\t\t// Called by the render loop\n\n\t\t\tfunction updateCrossFadeControls() {\n\n\t\t\t\tif ( idleWeight === 1 && walkWeight === 0 && runWeight === 0 ) {\n\n\t\t\t\t\tcrossFadeControls[ 0 ].disable();\n\t\t\t\t\tcrossFadeControls[ 1 ].enable();\n\t\t\t\t\tcrossFadeControls[ 2 ].disable();\n\t\t\t\t\tcrossFadeControls[ 3 ].disable();\n\n\t\t\t\t}\n\n\t\t\t\tif ( idleWeight === 0 && walkWeight === 1 && runWeight === 0 ) {\n\n\t\t\t\t\tcrossFadeControls[ 0 ].enable();\n\t\t\t\t\tcrossFadeControls[ 1 ].disable();\n\t\t\t\t\tcrossFadeControls[ 2 ].enable();\n\t\t\t\t\tcrossFadeControls[ 3 ].disable();\n\n\t\t\t\t}\n\n\t\t\t\tif ( idleWeight === 0 && walkWeight === 0 && runWeight === 1 ) {\n\n\t\t\t\t\tcrossFadeControls[ 0 ].disable();\n\t\t\t\t\tcrossFadeControls[ 1 ].disable();\n\t\t\t\t\tcrossFadeControls[ 2 ].disable();\n\t\t\t\t\tcrossFadeControls[ 3 ].enable();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tidleWeight = idleAction.getEffectiveWeight();\n\t\t\t\twalkWeight = walkAction.getEffectiveWeight();\n\t\t\t\trunWeight = runAction.getEffectiveWeight();\n\n\t\t\t\t// Update the panel values if weights are modified from \"outside\" (by crossfadings)\n\n\t\t\t\tupdateWeightSliders();\n\n\t\t\t\t// Enable/disable crossfade controls according to current weight values\n\n\t\t\t\tupdateCrossFadeControls();\n\n\t\t\t\t// Get the time elapsed since the last frame, used for mixer update (if not in single step mode)\n\n\t\t\t\tlet mixerUpdateDelta = clock.getDelta();\n\n\t\t\t\t// If in single step mode, make one step and then do nothing (until the user clicks again)\n\n\t\t\t\tif ( singleStepMode ) {\n\n\t\t\t\t\tmixerUpdateDelta = sizeOfNextStep;\n\t\t\t\t\tsizeOfNextStep = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// Update the animation mixer, the stats panel, and render this frame\n\n\t\t\t\tmixer.update( mixerUpdateDelta );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}"
  },
  {
    "title": "three.js webgl - additive animation - skinning",
    "tags": [
      "threejs",
      "webgl",
      "additive",
      "animation",
      "skinning"
    ],
    "description": "Example of three.js webgl - additive animation - skinning",
    "code": "import * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet scene, renderer, camera, stats;\n\t\t\tlet model, skeleton, mixer, clock;\n\n\t\t\tconst crossFadeControls = [];\n\n\t\t\tlet currentBaseAction = 'idle';\n\t\t\tconst allActions = [];\n\t\t\tconst baseActions = {\n\t\t\t\tidle: { weight: 1 },\n\t\t\t\twalk: { weight: 0 },\n\t\t\t\trun: { weight: 0 }\n\t\t\t};\n\t\t\tconst additiveActions = {\n\t\t\t\tsneak_pose: { weight: 0 },\n\t\t\t\tsad_pose: { weight: 0 },\n\t\t\t\tagree: { weight: 0 },\n\t\t\t\theadShake: { weight: 0 }\n\t\t\t};\n\t\t\tlet panelSettings, numAnimations;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xa0a0a0 );\n\t\t\t\tscene.fog = new THREE.Fog( 0xa0a0a0, 10, 50 );\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 3 );\n\t\t\t\themiLight.position.set( 0, 20, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( 3, 10, 10 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.top = 2;\n\t\t\t\tdirLight.shadow.camera.bottom = - 2;\n\t\t\t\tdirLight.shadow.camera.left = - 2;\n\t\t\t\tdirLight.shadow.camera.right = 2;\n\t\t\t\tdirLight.shadow.camera.near = 0.1;\n\t\t\t\tdirLight.shadow.camera.far = 40;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// ground\n\n\t\t\t\tconst mesh = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100 ), new THREE.MeshPhongMaterial( { color: 0xcbcbcb, depthWrite: false } ) );\n\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Xbot.glb', function ( gltf ) {\n\n\t\t\t\t\tmodel = gltf.scene;\n\t\t\t\t\tscene.add( model );\n\n\t\t\t\t\tmodel.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.isMesh ) object.castShadow = true;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tskeleton = new THREE.SkeletonHelper( model );\n\t\t\t\t\tskeleton.visible = false;\n\t\t\t\t\tscene.add( skeleton );\n\n\t\t\t\t\tconst animations = gltf.animations;\n\t\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\n\t\t\t\t\tnumAnimations = animations.length;\n\n\t\t\t\t\tfor ( let i = 0; i !== numAnimations; ++ i ) {\n\n\t\t\t\t\t\tlet clip = animations[ i ];\n\t\t\t\t\t\tconst name = clip.name;\n\n\t\t\t\t\t\tif ( baseActions[ name ] ) {\n\n\t\t\t\t\t\t\tconst action = mixer.clipAction( clip );\n\t\t\t\t\t\t\tactivateAction( action );\n\t\t\t\t\t\t\tbaseActions[ name ].action = action;\n\t\t\t\t\t\t\tallActions.push( action );\n\n\t\t\t\t\t\t} else if ( additiveActions[ name ] ) {\n\n\t\t\t\t\t\t\t// Make the clip additive and remove the reference frame\n\n\t\t\t\t\t\t\tTHREE.AnimationUtils.makeClipAdditive( clip );\n\n\t\t\t\t\t\t\tif ( clip.name.endsWith( '_pose' ) ) {\n\n\t\t\t\t\t\t\t\tclip = THREE.AnimationUtils.subclip( clip, clip.name, 2, 3, 30 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst action = mixer.clipAction( clip );\n\t\t\t\t\t\t\tactivateAction( action );\n\t\t\t\t\t\t\tadditiveActions[ name ].action = action;\n\t\t\t\t\t\t\tallActions.push( action );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcreatePanel();\n\n\t\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\t\tcamera.position.set( - 1, 2, 3 );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.enableZoom = false;\n\t\t\t\tcontrols.target.set( 0, 1, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction createPanel() {\n\n\t\t\t\tconst panel = new GUI( { width: 310 } );\n\n\t\t\t\tconst folder1 = panel.addFolder( 'Base Actions' );\n\t\t\t\tconst folder2 = panel.addFolder( 'Additive Action Weights' );\n\t\t\t\tconst folder3 = panel.addFolder( 'General Speed' );\n\n\t\t\t\tpanelSettings = {\n\t\t\t\t\t'modify time scale': 1.0\n\t\t\t\t};\n\n\t\t\t\tconst baseNames = [ 'None', ...Object.keys( baseActions ) ];\n\n\t\t\t\tfor ( let i = 0, l = baseNames.length; i !== l; ++ i ) {\n\n\t\t\t\t\tconst name = baseNames[ i ];\n\t\t\t\t\tconst settings = baseActions[ name ];\n\t\t\t\t\tpanelSettings[ name ] = function () {\n\n\t\t\t\t\t\tconst currentSettings = baseActions[ currentBaseAction ];\n\t\t\t\t\t\tconst currentAction = currentSettings ? currentSettings.action : null;\n\t\t\t\t\t\tconst action = settings ? settings.action : null;\n\n\t\t\t\t\t\tif ( currentAction !== action ) {\n\n\t\t\t\t\t\t\tprepareCrossFade( currentAction, action, 0.35 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t};\n\n\t\t\t\t\tcrossFadeControls.push( folder1.add( panelSettings, name ) );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( const name of Object.keys( additiveActions ) ) {\n\n\t\t\t\t\tconst settings = additiveActions[ name ];\n\n\t\t\t\t\tpanelSettings[ name ] = settings.weight;\n\t\t\t\t\tfolder2.add( panelSettings, name, 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {\n\n\t\t\t\t\t\tsetWeight( settings.action, weight );\n\t\t\t\t\t\tsettings.weight = weight;\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tfolder3.add( panelSettings, 'modify time scale', 0.0, 1.5, 0.01 ).onChange( modifyTimeScale );\n\n\t\t\t\tfolder1.open();\n\t\t\t\tfolder2.open();\n\t\t\t\tfolder3.open();\n\n\t\t\t\tcrossFadeControls.forEach( function ( control ) {\n\n\t\t\t\t\tcontrol.setInactive = function () {\n\n\t\t\t\t\t\tcontrol.domElement.classList.add( 'control-inactive' );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tcontrol.setActive = function () {\n\n\t\t\t\t\t\tcontrol.domElement.classList.remove( 'control-inactive' );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tconst settings = baseActions[ control.property ];\n\n\t\t\t\t\tif ( ! settings || ! settings.weight ) {\n\n\t\t\t\t\t\tcontrol.setInactive();\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction activateAction( action ) {\n\n\t\t\t\tconst clip = action.getClip();\n\t\t\t\tconst settings = baseActions[ clip.name ] || additiveActions[ clip.name ];\n\t\t\t\tsetWeight( action, settings.weight );\n\t\t\t\taction.play();\n\n\t\t\t}\n\n\t\t\tfunction modifyTimeScale( speed ) {\n\n\t\t\t\tmixer.timeScale = speed;\n\n\t\t\t}\n\n\t\t\tfunction prepareCrossFade( startAction, endAction, duration ) {\n\n\t\t\t\t// If the current action is 'idle', execute the crossfade immediately;\n\t\t\t\t// else wait until the current action has finished its current loop\n\n\t\t\t\tif ( currentBaseAction === 'idle' || ! startAction || ! endAction ) {\n\n\t\t\t\t\texecuteCrossFade( startAction, endAction, duration );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsynchronizeCrossFade( startAction, endAction, duration );\n\n\t\t\t\t}\n\n\t\t\t\t// Update control colors\n\n\t\t\t\tif ( endAction ) {\n\n\t\t\t\t\tconst clip = endAction.getClip();\n\t\t\t\t\tcurrentBaseAction = clip.name;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentBaseAction = 'None';\n\n\t\t\t\t}\n\n\t\t\t\tcrossFadeControls.forEach( function ( control ) {\n\n\t\t\t\t\tconst name = control.property;\n\n\t\t\t\t\tif ( name === currentBaseAction ) {\n\n\t\t\t\t\t\tcontrol.setActive();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcontrol.setInactive();\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction synchronizeCrossFade( startAction, endAction, duration ) {\n\n\t\t\t\tmixer.addEventListener( 'loop', onLoopFinished );\n\n\t\t\t\tfunction onLoopFinished( event ) {\n\n\t\t\t\t\tif ( event.action === startAction ) {\n\n\t\t\t\t\t\tmixer.removeEventListener( 'loop', onLoopFinished );\n\n\t\t\t\t\t\texecuteCrossFade( startAction, endAction, duration );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction executeCrossFade( startAction, endAction, duration ) {\n\n\t\t\t\t// Not only the start action, but also the end action must get a weight of 1 before fading\n\t\t\t\t// (concerning the start action this is already guaranteed in this place)\n\n\t\t\t\tif ( endAction ) {\n\n\t\t\t\t\tsetWeight( endAction, 1 );\n\t\t\t\t\tendAction.time = 0;\n\n\t\t\t\t\tif ( startAction ) {\n\n\t\t\t\t\t\t// Crossfade with warping\n\n\t\t\t\t\t\tstartAction.crossFadeTo( endAction, duration, true );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Fade in\n\n\t\t\t\t\t\tendAction.fadeIn( duration );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Fade out\n\n\t\t\t\t\tstartAction.fadeOut( duration );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// This function is needed, since animationAction.crossFadeTo() disables its start action and sets\n\t\t\t// the start action's timeScale to ((start animation's duration) / (end animation's duration))\n\n\t\t\tfunction setWeight( action, weight ) {\n\n\t\t\t\taction.enabled = true;\n\t\t\t\taction.setEffectiveTimeScale( 1 );\n\t\t\t\taction.setEffectiveWeight( weight );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\t// Render loop\n\n\t\t\t\tfor ( let i = 0; i !== numAnimations; ++ i ) {\n\n\t\t\t\t\tconst action = allActions[ i ];\n\t\t\t\t\tconst clip = action.getClip();\n\t\t\t\t\tconst settings = baseActions[ clip.name ] || additiveActions[ clip.name ];\n\t\t\t\t\tsettings.weight = action.getEffectiveWeight();\n\n\t\t\t\t}\n\n\t\t\t\t// Get the time elapsed since the last frame, used for mixer update\n\n\t\t\t\tconst mixerUpdateDelta = clock.getDelta();\n\n\t\t\t\t// Update the animation mixer, the stats panel, and render this frame\n\n\t\t\t\tmixer.update( mixerUpdateDelta );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}"
  },
  {
    "title": "three.js webgl - animation - skinning - ik",
    "tags": [
      "threejs",
      "webgl",
      "animation",
      "skinning",
      "ik"
    ],
    "description": "Example of three.js webgl - animation - skinning - ik",
    "code": "import * as THREE from 'three';\n\n\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\timport { TransformControls } from 'three/addons/controls/TransformControls.js';\n\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\t\timport { CCDIKSolver, CCDIKHelper } from 'three/addons/animation/CCDIKSolver.js';\n\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\tlet scene, camera, renderer, orbitControls, transformControls;\n\t\tlet mirrorSphereCamera;\n\n\t\tconst OOI = {};\n\t\tlet IKSolver;\n\n\t\tlet stats, gui, conf;\n\t\tconst v0 = new THREE.Vector3();\n\n\t\tinit();\n\n\t\tasync function init() {\n\n\t\t\tconf = {\n\t\t\t\tfollowSphere: false,\n\t\t\t\tturnHead: true,\n\t\t\t\tik_solver: true,\n\t\t\t\tupdate: updateIK\n\t\t\t};\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.fog = new THREE.FogExp2( 0xffffff, .17 );\n\t\t\tscene.background = new THREE.Color( 0xffffff );\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 0.001, 5000 );\n\t\t\tcamera.position.set( 0.9728517749133652, 1.1044765132727201, 0.7316689528482836 );\n\t\t\tcamera.lookAt( scene.position );\n\n\t\t\tconst ambientLight = new THREE.AmbientLight( 0xffffff, 8 ); // soft white light\n\t\t\tscene.add( ambientLight );\n\n\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/' );\n\t\t\tconst gltfLoader = new GLTFLoader();\n\t\t\tgltfLoader.setDRACOLoader( dracoLoader );\n\n\t\t\tconst gltf = await gltfLoader.loadAsync( 'models/gltf/kira.glb' );\n\t\t\tgltf.scene.traverse( n => {\n\n\t\t\t\tif ( n.name === 'head' ) OOI.head = n;\n\t\t\t\tif ( n.name === 'lowerarm_l' ) OOI.lowerarm_l = n;\n\t\t\t\tif ( n.name === 'Upperarm_l' ) OOI.Upperarm_l = n;\n\t\t\t\tif ( n.name === 'hand_l' ) OOI.hand_l = n;\n\t\t\t\tif ( n.name === 'target_hand_l' ) OOI.target_hand_l = n;\n\n\t\t\t\tif ( n.name === 'boule' ) OOI.sphere = n;\n\t\t\t\tif ( n.name === 'Kira_Shirt_left' ) OOI.kira = n;\n\n\t\t\t} );\n\t\t\tscene.add( gltf.scene );\n\n\t\t\tconst targetPosition = OOI.sphere.position.clone(); // for orbit controls\n\t\t\tOOI.hand_l.attach( OOI.sphere );\n\n\t\t\t// mirror sphere cube-camera\n\t\t\tconst cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 1024 );\n\t\t\tmirrorSphereCamera = new THREE.CubeCamera( 0.05, 50, cubeRenderTarget );\n\t\t\tscene.add( mirrorSphereCamera );\n\t\t\tconst mirrorSphereMaterial = new THREE.MeshBasicMaterial( { envMap: cubeRenderTarget.texture } );\n\t\t\tOOI.sphere.material = mirrorSphereMaterial;\n\n\t\t\tOOI.kira.add( OOI.kira.skeleton.bones[ 0 ] );\n\t\t\tconst iks = [\n\t\t\t\t{\n\t\t\t\t\ttarget: 22, // \"target_hand_l\"\n\t\t\t\t\teffector: 6, // \"hand_l\"\n\t\t\t\t\tlinks: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tindex: 5, // \"lowerarm_l\"\n\t\t\t\t\t\t\trotationMin: new THREE.Vector3( 1.2, - 1.8, - .4 ),\n\t\t\t\t\t\t\trotationMax: new THREE.Vector3( 1.7, - 1.1, .3 )\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tindex: 4, // \"Upperarm_l\"\n\t\t\t\t\t\t\trotationMin: new THREE.Vector3( 0.1, - 0.7, - 1.8 ),\n\t\t\t\t\t\t\trotationMax: new THREE.Vector3( 1.1, 0, - 1.4 )\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t}\n\t\t\t];\n\t\t\tIKSolver = new CCDIKSolver( OOI.kira, iks );\n\t\t\tconst ccdikhelper = new CCDIKHelper( OOI.kira, iks, 0.01 );\n\t\t\tscene.add( ccdikhelper );\n\n\t\t\tgui = new GUI();\n\t\t\tgui.add( conf, 'followSphere' ).name( 'follow sphere' );\n\t\t\tgui.add( conf, 'turnHead' ).name( 'turn head' );\n\t\t\tgui.add( conf, 'ik_solver' ).name( 'IK auto update' );\n\t\t\tgui.add( conf, 'update' ).name( 'IK manual update()' );\n\t\t\tgui.open();\n\n\t\t\t//\n\n\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t//\n\n\t\t\torbitControls = new OrbitControls( camera, renderer.domElement );\n\t\t\torbitControls.minDistance = 0.2;\n\t\t\torbitControls.maxDistance = 1.5;\n\t\t\torbitControls.enableDamping = true;\n\t\t\torbitControls.target.copy( targetPosition );\n\n\t\t\ttransformControls = new TransformControls( camera, renderer.domElement );\n\t\t\ttransformControls.size = 0.75;\n\t\t\ttransformControls.showX = false;\n\t\t\ttransformControls.space = 'world';\n\t\t\ttransformControls.attach( OOI.target_hand_l );\n\t\t\tscene.add( transformControls.getHelper() );\n\n\t\t\t// disable orbitControls while using transformControls\n\t\t\ttransformControls.addEventListener( 'mouseDown', () => orbitControls.enabled = false );\n\t\t\ttransformControls.addEventListener( 'mouseUp', () => orbitControls.enabled = true );\n\n\t\t\t//\n\n\t\t\tstats = new Stats();\n\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize, false );\n\n\t\t}\n\n\t\tfunction animate( ) {\n\n\t\t\tif ( OOI.sphere && mirrorSphereCamera ) {\n\n\t\t\t\tOOI.sphere.visible = false;\n\t\t\t\tOOI.sphere.getWorldPosition( mirrorSphereCamera.position );\n\t\t\t\tmirrorSphereCamera.update( renderer, scene );\n\t\t\t\tOOI.sphere.visible = true;\n\n\t\t\t}\n\n\t\t\tif ( OOI.sphere && conf.followSphere ) {\n\n\t\t\t\t// orbitControls follows the sphere\n\t\t\t\tOOI.sphere.getWorldPosition( v0 );\n\t\t\t\torbitControls.target.lerp( v0, 0.1 );\n\n\t\t\t}\n\n\t\t\tif ( OOI.head && OOI.sphere && conf.turnHead ) {\n\n\t\t\t\t// turn head\n\t\t\t\tOOI.sphere.getWorldPosition( v0 );\n\t\t\t\tOOI.head.lookAt( v0 );\n\t\t\t\tOOI.head.rotation.set( OOI.head.rotation.x, OOI.head.rotation.y + Math.PI, OOI.head.rotation.z );\n\n\t\t\t}\n\n\t\t\tif ( conf.ik_solver ) {\n\n\t\t\t\tupdateIK();\n\n\t\t\t}\n\n\t\t\torbitControls.update();\n\t\t\trenderer.render( scene, camera );\n\n\t\t\tstats.update(); // fps stats\n\n\t\t}\n\n\t\tfunction updateIK() {\n\n\t\t\tif ( IKSolver ) IKSolver.update();\n\n\t\t\tscene.traverse( function ( object ) {\n\n\t\t\t\tif ( object.isSkinnedMesh ) object.computeBoundingSphere();\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}"
  },
  {
    "title": "three.js webgl - skinning and morphing",
    "tags": [
      "threejs",
      "webgl",
      "skinning",
      "morphing"
    ],
    "description": "Example of three.js webgl - skinning and morphing",
    "code": "import * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet container, stats, clock, gui, mixer, actions, activeAction, previousAction;\n\t\t\tlet camera, scene, renderer, model, face;\n\n\t\t\tconst api = { state: 'Walking' };\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 100 );\n\t\t\t\tcamera.position.set( - 5, 3, 10 );\n\t\t\t\tcamera.lookAt( 0, 2, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xe0e0e0 );\n\t\t\t\tscene.fog = new THREE.Fog( 0xe0e0e0, 20, 100 );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t// lights\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 3 );\n\t\t\t\themiLight.position.set( 0, 20, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( 0, 20, 10 );\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// ground\n\n\t\t\t\tconst mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0xcbcbcb, depthWrite: false } ) );\n\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst grid = new THREE.GridHelper( 200, 40, 0x000000, 0x000000 );\n\t\t\t\tgrid.material.opacity = 0.2;\n\t\t\t\tgrid.material.transparent = true;\n\t\t\t\tscene.add( grid );\n\n\t\t\t\t// model\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/RobotExpressive/RobotExpressive.glb', function ( gltf ) {\n\n\t\t\t\t\tmodel = gltf.scene;\n\t\t\t\t\tscene.add( model );\n\n\t\t\t\t\tcreateGUI( model, gltf.animations );\n\n\t\t\t\t}, undefined, function ( e ) {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// stats\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t}\n\n\t\t\tfunction createGUI( model, animations ) {\n\n\t\t\t\tconst states = [ 'Idle', 'Walking', 'Running', 'Dance', 'Death', 'Sitting', 'Standing' ];\n\t\t\t\tconst emotes = [ 'Jump', 'Yes', 'No', 'Wave', 'Punch', 'ThumbsUp' ];\n\n\t\t\t\tgui = new GUI();\n\n\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\n\t\t\t\tactions = {};\n\n\t\t\t\tfor ( let i = 0; i < animations.length; i ++ ) {\n\n\t\t\t\t\tconst clip = animations[ i ];\n\t\t\t\t\tconst action = mixer.clipAction( clip );\n\t\t\t\t\tactions[ clip.name ] = action;\n\n\t\t\t\t\tif ( emotes.indexOf( clip.name ) >= 0 || states.indexOf( clip.name ) >= 4 ) {\n\n\t\t\t\t\t\taction.clampWhenFinished = true;\n\t\t\t\t\t\taction.loop = THREE.LoopOnce;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// states\n\n\t\t\t\tconst statesFolder = gui.addFolder( 'States' );\n\n\t\t\t\tconst clipCtrl = statesFolder.add( api, 'state' ).options( states );\n\n\t\t\t\tclipCtrl.onChange( function () {\n\n\t\t\t\t\tfadeToAction( api.state, 0.5 );\n\n\t\t\t\t} );\n\n\t\t\t\tstatesFolder.open();\n\n\t\t\t\t// emotes\n\n\t\t\t\tconst emoteFolder = gui.addFolder( 'Emotes' );\n\n\t\t\t\tfunction createEmoteCallback( name ) {\n\n\t\t\t\t\tapi[ name ] = function () {\n\n\t\t\t\t\t\tfadeToAction( name, 0.2 );\n\n\t\t\t\t\t\tmixer.addEventListener( 'finished', restoreState );\n\n\t\t\t\t\t};\n\n\t\t\t\t\temoteFolder.add( api, name );\n\n\t\t\t\t}\n\n\t\t\t\tfunction restoreState() {\n\n\t\t\t\t\tmixer.removeEventListener( 'finished', restoreState );\n\n\t\t\t\t\tfadeToAction( api.state, 0.2 );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < emotes.length; i ++ ) {\n\n\t\t\t\t\tcreateEmoteCallback( emotes[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\temoteFolder.open();\n\n\t\t\t\t// expressions\n\n\t\t\t\tface = model.getObjectByName( 'Head_4' );\n\n\t\t\t\tconst expressions = Object.keys( face.morphTargetDictionary );\n\t\t\t\tconst expressionFolder = gui.addFolder( 'Expressions' );\n\n\t\t\t\tfor ( let i = 0; i < expressions.length; i ++ ) {\n\n\t\t\t\t\texpressionFolder.add( face.morphTargetInfluences, i, 0, 1, 0.01 ).name( expressions[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tactiveAction = actions[ 'Walking' ];\n\t\t\t\tactiveAction.play();\n\n\t\t\t\texpressionFolder.open();\n\n\t\t\t}\n\n\t\t\tfunction fadeToAction( name, duration ) {\n\n\t\t\t\tpreviousAction = activeAction;\n\t\t\t\tactiveAction = actions[ name ];\n\n\t\t\t\tif ( previousAction !== activeAction ) {\n\n\t\t\t\t\tpreviousAction.fadeOut( duration );\n\n\t\t\t\t}\n\n\t\t\t\tactiveAction\n\t\t\t\t\t.reset()\n\t\t\t\t\t.setEffectiveTimeScale( 1 )\n\t\t\t\t\t.setEffectiveWeight( 1 )\n\t\t\t\t\t.fadeIn( duration )\n\t\t\t\t\t.play();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst dt = clock.getDelta();\n\n\t\t\t\tif ( mixer ) mixer.update( dt );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}"
  },
  {
    "title": "Multiple animated skinned meshes",
    "tags": [
      "multiple",
      "animated",
      "skinned",
      "meshes"
    ],
    "description": "Example of Multiple animated skinned meshes",
    "code": "import * as THREE from 'three';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, clock;\n\t\t\tlet model, animations;\n\n\t\t\tconst mixers = [], objects = [];\n\n\t\t\tconst params = {\n\t\t\t\tsharedSkeleton: false\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 2, 3, - 6 );\n\t\t\t\tcamera.lookAt( 0, 1, 0 );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xa0a0a0 );\n\t\t\t\tscene.fog = new THREE.Fog( 0xa0a0a0, 10, 50 );\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 3 );\n\t\t\t\themiLight.position.set( 0, 20, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( - 3, 10, - 10 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.top = 4;\n\t\t\t\tdirLight.shadow.camera.bottom = - 4;\n\t\t\t\tdirLight.shadow.camera.left = - 4;\n\t\t\t\tdirLight.shadow.camera.right = 4;\n\t\t\t\tdirLight.shadow.camera.near = 0.1;\n\t\t\t\tdirLight.shadow.camera.far = 40;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );\n\n\t\t\t\t// ground\n\n\t\t\t\tconst mesh = new THREE.Mesh( new THREE.PlaneGeometry( 200, 200 ), new THREE.MeshPhongMaterial( { color: 0xcbcbcb, depthWrite: false } ) );\n\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Soldier.glb', function ( gltf ) {\n\n\t\t\t\t\tmodel = gltf.scene;\n\t\t\t\t\tanimations = gltf.animations;\n\n\t\t\t\t\tmodel.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.isMesh ) object.castShadow = true;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tsetupDefaultScene();\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'sharedSkeleton' ).onChange( function () {\n\n\t\t\t\t\tclearScene();\n\t\t\t\n\t\t\t\t\tif ( params.sharedSkeleton === true ) {\n\n\t\t\t\t\t\tsetupSharedSkeletonScene();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tsetupDefaultScene();\n\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t} );\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction clearScene() {\n\n\t\t\t\tfor ( const mixer of mixers ) {\n\n\t\t\t\t\tmixer.stopAllAction();\n\n\t\t\t\t}\n\n\t\t\t\tmixers.length = 0;\n\n\t\t\t\t//\n\n\t\t\t\tfor ( const object of objects ) {\n\n\t\t\t\t\tscene.remove( object );\n\n\t\t\t\t\tscene.traverse( function ( child ) {\n\n\t\t\t\t\t\tif ( child.isSkinnedMesh ) child.skeleton.dispose();\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction setupDefaultScene() {\n\n\t\t\t\t// three cloned models with independent skeletons.\n\t\t\t\t// each model can have its own animation state\n\n\t\t\t\tconst model1 = SkeletonUtils.clone( model );\n\t\t\t\tconst model2 = SkeletonUtils.clone( model );\n\t\t\t\tconst model3 = SkeletonUtils.clone( model );\n\n\t\t\t\tmodel1.position.x = - 2;\n\t\t\t\tmodel2.position.x = 0;\n\t\t\t\tmodel3.position.x = 2;\n\n\t\t\t\tconst mixer1 = new THREE.AnimationMixer( model1 );\n\t\t\t\tconst mixer2 = new THREE.AnimationMixer( model2 );\n\t\t\t\tconst mixer3 = new THREE.AnimationMixer( model3 );\n\n\t\t\t\tmixer1.clipAction( animations[ 0 ] ).play(); // idle\n\t\t\t\tmixer2.clipAction( animations[ 1 ] ).play(); // run\n\t\t\t\tmixer3.clipAction( animations[ 3 ] ).play(); // walk\n\n\t\t\t\tscene.add( model1, model2, model3 );\n\t\t\t\n\t\t\t\tobjects.push( model1, model2, model3 );\n\t\t\t\tmixers.push( mixer1, mixer2, mixer3 );\n\n\t\t\t}\n\n\t\t\tfunction setupSharedSkeletonScene() {\n\n\t\t\t\t// three cloned models with a single shared skeleton.\n\t\t\t\t// all models share the same animation state\n\n\t\t\t\tconst sharedModel = SkeletonUtils.clone( model );\n\t\t\t\tconst shareSkinnedMesh = sharedModel.getObjectByName( 'vanguard_Mesh' );\n\t\t\t\tconst sharedSkeleton = shareSkinnedMesh.skeleton;\n\t\t\t\tconst sharedParentBone = sharedModel.getObjectByName( 'mixamorigHips' );\n\t\t\t\tscene.add( sharedParentBone ); // the bones need to be in the scene for the animation to work\n\n\t\t\t\tconst model1 = shareSkinnedMesh.clone();\n\t\t\t\tconst model2 = shareSkinnedMesh.clone();\n\t\t\t\tconst model3 = shareSkinnedMesh.clone();\n\n\t\t\t\tmodel1.bindMode = THREE.DetachedBindMode;\n\t\t\t\tmodel2.bindMode = THREE.DetachedBindMode;\n\t\t\t\tmodel3.bindMode = THREE.DetachedBindMode;\n\n\t\t\t\tconst identity = new THREE.Matrix4();\n\n\t\t\t\tmodel1.bind( sharedSkeleton, identity );\n\t\t\t\tmodel2.bind( sharedSkeleton, identity );\n\t\t\t\tmodel3.bind( sharedSkeleton, identity );\n\n\t\t\t\tmodel1.position.x = - 2;\n\t\t\t\tmodel2.position.x = 0;\n\t\t\t\tmodel3.position.x = 2;\n\n\t\t\t\t// apply transformation from the glTF asset\n\n\t\t\t\tmodel1.scale.setScalar( 0.01 );\n\t\t\t\tmodel1.rotation.x = - Math.PI * 0.5;\n\t\t\t\tmodel2.scale.setScalar( 0.01 );\n\t\t\t\tmodel2.rotation.x = - Math.PI * 0.5;\n\t\t\t\tmodel3.scale.setScalar( 0.01 );\n\t\t\t\tmodel3.rotation.x = - Math.PI * 0.5;\n\n\t\t\t\t//\n\n\t\t\t\tconst mixer = new THREE.AnimationMixer( sharedParentBone );\n\t\t\t\tmixer.clipAction( animations[ 1 ] ).play();\n\n\t\t\t\tscene.add( sharedParentBone, model1, model2, model3 );\n\t\t\t\n\t\t\t\tobjects.push( sharedParentBone, model1, model2, model3 );\n\t\t\t\tmixers.push( mixer );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tfor ( const mixer of mixers ) mixer.update( delta );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}"
  },
  {
    "title": "three.js webgl - cameras",
    "tags": [
      "threejs",
      "webgl",
      "cameras"
    ],
    "description": "Example of three.js webgl - cameras",
    "code": "import * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet SCREEN_WIDTH = window.innerWidth;\n\t\t\tlet SCREEN_HEIGHT = window.innerHeight;\n\t\t\tlet aspect = SCREEN_WIDTH / SCREEN_HEIGHT;\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer, mesh;\n\t\t\tlet cameraRig, activeCamera, activeHelper;\n\t\t\tlet cameraPerspective, cameraOrtho;\n\t\t\tlet cameraPerspectiveHelper, cameraOrthoHelper;\n\t\t\tconst frustumSize = 600;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, 0.5 * aspect, 1, 10000 );\n\t\t\t\tcamera.position.z = 2500;\n\n\t\t\t\tcameraPerspective = new THREE.PerspectiveCamera( 50, 0.5 * aspect, 150, 1000 );\n\n\t\t\t\tcameraPerspectiveHelper = new THREE.CameraHelper( cameraPerspective );\n\t\t\t\tscene.add( cameraPerspectiveHelper );\n\n\t\t\t\t//\n\t\t\t\tcameraOrtho = new THREE.OrthographicCamera( 0.5 * frustumSize * aspect / - 2, 0.5 * frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 150, 1000 );\n\n\t\t\t\tcameraOrthoHelper = new THREE.CameraHelper( cameraOrtho );\n\t\t\t\tscene.add( cameraOrthoHelper );\n\n\t\t\t\t//\n\n\t\t\t\tactiveCamera = cameraPerspective;\n\t\t\t\tactiveHelper = cameraPerspectiveHelper;\n\n\n\t\t\t\t// counteract different front orientation of cameras vs rig\n\n\t\t\t\tcameraOrtho.rotation.y = Math.PI;\n\t\t\t\tcameraPerspective.rotation.y = Math.PI;\n\n\t\t\t\tcameraRig = new THREE.Group();\n\n\t\t\t\tcameraRig.add( cameraPerspective );\n\t\t\t\tcameraRig.add( cameraOrtho );\n\n\t\t\t\tscene.add( cameraRig );\n\n\t\t\t\t//\n\n\t\t\t\tmesh = new THREE.Mesh(\n\t\t\t\t\tnew THREE.SphereGeometry( 100, 16, 8 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } )\n\t\t\t\t);\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst mesh2 = new THREE.Mesh(\n\t\t\t\t\tnew THREE.SphereGeometry( 50, 16, 8 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0x00ff00, wireframe: true } )\n\t\t\t\t);\n\t\t\t\tmesh2.position.y = 150;\n\t\t\t\tmesh.add( mesh2 );\n\n\t\t\t\tconst mesh3 = new THREE.Mesh(\n\t\t\t\t\tnew THREE.SphereGeometry( 5, 16, 8 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0x0000ff, wireframe: true } )\n\t\t\t\t);\n\t\t\t\tmesh3.position.z = 150;\n\t\t\t\tcameraRig.add( mesh3 );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tconst vertices = [];\n\n\t\t\t\tfor ( let i = 0; i < 10000; i ++ ) {\n\n\t\t\t\t\tvertices.push( THREE.MathUtils.randFloatSpread( 2000 ) ); // x\n\t\t\t\t\tvertices.push( THREE.MathUtils.randFloatSpread( 2000 ) ); // y\n\t\t\t\t\tvertices.push( THREE.MathUtils.randFloatSpread( 2000 ) ); // z\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\n\t\t\t\tconst particles = new THREE.Points( geometry, new THREE.PointsMaterial( { color: 0x888888 } ) );\n\t\t\t\tscene.add( particles );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tdocument.addEventListener( 'keydown', onKeyDown );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onKeyDown( event ) {\n\n\t\t\t\tswitch ( event.keyCode ) {\n\n\t\t\t\t\tcase 79: /*O*/\n\n\t\t\t\t\t\tactiveCamera = cameraOrtho;\n\t\t\t\t\t\tactiveHelper = cameraOrthoHelper;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 80: /*P*/\n\n\t\t\t\t\t\tactiveCamera = cameraPerspective;\n\t\t\t\t\t\tactiveHelper = cameraPerspectiveHelper;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tSCREEN_WIDTH = window.innerWidth;\n\t\t\t\tSCREEN_HEIGHT = window.innerHeight;\n\t\t\t\taspect = SCREEN_WIDTH / SCREEN_HEIGHT;\n\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\n\t\t\t\tcamera.aspect = 0.5 * aspect;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\tcameraPerspective.aspect = 0.5 * aspect;\n\t\t\t\tcameraPerspective.updateProjectionMatrix();\n\n\t\t\t\tcameraOrtho.left = - 0.5 * frustumSize * aspect / 2;\n\t\t\t\tcameraOrtho.right = 0.5 * frustumSize * aspect / 2;\n\t\t\t\tcameraOrtho.top = frustumSize / 2;\n\t\t\t\tcameraOrtho.bottom = - frustumSize / 2;\n\t\t\t\tcameraOrtho.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst r = Date.now() * 0.0005;\n\n\t\t\t\tmesh.position.x = 700 * Math.cos( r );\n\t\t\t\tmesh.position.z = 700 * Math.sin( r );\n\t\t\t\tmesh.position.y = 700 * Math.sin( r );\n\n\t\t\t\tmesh.children[ 0 ].position.x = 70 * Math.cos( 2 * r );\n\t\t\t\tmesh.children[ 0 ].position.z = 70 * Math.sin( r );\n\n\t\t\t\tif ( activeCamera === cameraPerspective ) {\n\n\t\t\t\t\tcameraPerspective.fov = 35 + 30 * Math.sin( 0.5 * r );\n\t\t\t\t\tcameraPerspective.far = mesh.position.length();\n\t\t\t\t\tcameraPerspective.updateProjectionMatrix();\n\n\t\t\t\t\tcameraPerspectiveHelper.update();\n\t\t\t\t\tcameraPerspectiveHelper.visible = true;\n\n\t\t\t\t\tcameraOrthoHelper.visible = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcameraOrtho.far = mesh.position.length();\n\t\t\t\t\tcameraOrtho.updateProjectionMatrix();\n\n\t\t\t\t\tcameraOrthoHelper.update();\n\t\t\t\t\tcameraOrthoHelper.visible = true;\n\n\t\t\t\t\tcameraPerspectiveHelper.visible = false;\n\n\t\t\t\t}\n\n\t\t\t\tcameraRig.lookAt( mesh.position );\n\n\t\t\t\t//\n\n\t\t\t\tactiveHelper.visible = false;\n\n\t\t\t\trenderer.setClearColor( 0x000000, 1 );\n\t\t\t\trenderer.setScissor( 0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.setViewport( 0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.render( scene, activeCamera );\n\n\t\t\t\t//\n\n\t\t\t\tactiveHelper.visible = true;\n\n\t\t\t\trenderer.setClearColor( 0x111111, 1 );\n\t\t\t\trenderer.setScissor( SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.setViewport( SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}"
  },
  {
    "title": "three.js webgl - arraycamera",
    "tags": [
      "threejs",
      "webgl",
      "arraycamera"
    ],
    "description": "Example of three.js webgl - arraycamera",
    "code": "import * as THREE from 'three';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet mesh;\n\t\t\tconst AMOUNT = 6;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst ASPECT_RATIO = window.innerWidth / window.innerHeight;\n\n\t\t\t\tconst WIDTH = ( window.innerWidth / AMOUNT ) * window.devicePixelRatio;\n\t\t\t\tconst HEIGHT = ( window.innerHeight / AMOUNT ) * window.devicePixelRatio;\n\n\t\t\t\tconst cameras = [];\n\n\t\t\t\tfor ( let y = 0; y < AMOUNT; y ++ ) {\n\n\t\t\t\t\tfor ( let x = 0; x < AMOUNT; x ++ ) {\n\n\t\t\t\t\t\tconst subcamera = new THREE.PerspectiveCamera( 40, ASPECT_RATIO, 0.1, 10 );\n\t\t\t\t\t\tsubcamera.viewport = new THREE.Vector4( Math.floor( x * WIDTH ), Math.floor( y * HEIGHT ), Math.ceil( WIDTH ), Math.ceil( HEIGHT ) );\n\t\t\t\t\t\tsubcamera.position.x = ( x / AMOUNT ) - 0.5;\n\t\t\t\t\t\tsubcamera.position.y = 0.5 - ( y / AMOUNT );\n\t\t\t\t\t\tsubcamera.position.z = 1.5;\n\t\t\t\t\t\tsubcamera.position.multiplyScalar( 2 );\n\t\t\t\t\t\tsubcamera.lookAt( 0, 0, 0 );\n\t\t\t\t\t\tsubcamera.updateMatrixWorld();\n\t\t\t\t\t\tcameras.push( subcamera );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcamera = new THREE.ArrayCamera( cameras );\n\t\t\t\tcamera.position.z = 3;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x999999 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0.5, 0.5, 1 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.camera.zoom = 4; // tighter shadow map\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst geometryBackground = new THREE.PlaneGeometry( 100, 100 );\n\t\t\t\tconst materialBackground = new THREE.MeshPhongMaterial( { color: 0x000066 } );\n\n\t\t\t\tconst background = new THREE.Mesh( geometryBackground, materialBackground );\n\t\t\t\tbackground.receiveShadow = true;\n\t\t\t\tbackground.position.set( 0, 0, - 1 );\n\t\t\t\tscene.add( background );\n\n\t\t\t\tconst geometryCylinder = new THREE.CylinderGeometry( 0.5, 0.5, 1, 32 );\n\t\t\t\tconst materialCylinder = new THREE.MeshPhongMaterial( { color: 0xff0000 } );\n\n\t\t\t\tmesh = new THREE.Mesh( geometryCylinder, materialCylinder );\n\t\t\t\tmesh.castShadow = true;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst ASPECT_RATIO = window.innerWidth / window.innerHeight;\n\t\t\t\tconst WIDTH = ( window.innerWidth / AMOUNT ) * window.devicePixelRatio;\n\t\t\t\tconst HEIGHT = ( window.innerHeight / AMOUNT ) * window.devicePixelRatio;\n\n\t\t\t\tcamera.aspect = ASPECT_RATIO;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\tfor ( let y = 0; y < AMOUNT; y ++ ) {\n\n\t\t\t\t\tfor ( let x = 0; x < AMOUNT; x ++ ) {\n\n\t\t\t\t\t\tconst subcamera = camera.cameras[ AMOUNT * y + x ];\n\n\t\t\t\t\t\tsubcamera.viewport.set(\n\t\t\t\t\t\t\tMath.floor( x * WIDTH ),\n\t\t\t\t\t\t\tMath.floor( y * HEIGHT ),\n\t\t\t\t\t\t\tMath.ceil( WIDTH ),\n\t\t\t\t\t\t\tMath.ceil( HEIGHT ) );\n\n\t\t\t\t\t\tsubcamera.aspect = ASPECT_RATIO;\n\t\t\t\t\t\tsubcamera.updateProjectionMatrix();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tmesh.rotation.x += 0.005;\n\t\t\t\tmesh.rotation.z += 0.01;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}"
  },
  {
    "title": "three.js webgl - cameras - logarithmic depth buffer",
    "tags": [
      "threejs",
      "webgl",
      "cameras",
      "logarithmic",
      "depth",
      "buffer"
    ],
    "description": "Example of three.js webgl - cameras - logarithmic depth buffer",
    "code": "import * as THREE from 'three';\n\n\t\t\timport { FontLoader } from 'three/addons/loaders/FontLoader.js';\n\t\t\timport { TextGeometry } from 'three/addons/geometries/TextGeometry.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\t// 1 micrometer to 100 billion light years in one scene, with 1 unit = 1 meter?  preposterous!  and yet...\n\t\t\tconst NEAR = 1e-6, FAR = 1e27;\n\t\t\tlet SCREEN_WIDTH = window.innerWidth;\n\t\t\tlet SCREEN_HEIGHT = window.innerHeight;\n\t\t\tlet screensplit = .25, screensplit_right = 0;\n\t\t\tconst mouse = [ .5, .5 ];\n\t\t\tlet zoompos = - 100, minzoomspeed = .015;\n\t\t\tlet zoomspeed = minzoomspeed;\n\n\t\t\tlet container, border, stats;\n\t\t\tconst objects = {};\n\n\t\t\t// Generate a number of text labels, from 1µm in size up to 100,000,000 light years\n\t\t\t// Try to use some descriptive real-world examples of objects at each scale\n\n\t\t\tconst labeldata = [\n\t\t\t\t{ size: .01, scale: 0.0001, label: 'microscopic (1µm)' }, // FIXME - triangulating text fails at this size, so we scale instead\n\t\t\t\t{ size: .01, scale: 0.1, label: 'minuscule (1mm)' },\n\t\t\t\t{ size: .01, scale: 1.0, label: 'tiny (1cm)' },\n\t\t\t\t{ size: 1, scale: 1.0, label: 'child-sized (1m)' },\n\t\t\t\t{ size: 10, scale: 1.0, label: 'tree-sized (10m)' },\n\t\t\t\t{ size: 100, scale: 1.0, label: 'building-sized (100m)' },\n\t\t\t\t{ size: 1000, scale: 1.0, label: 'medium (1km)' },\n\t\t\t\t{ size: 10000, scale: 1.0, label: 'city-sized (10km)' },\n\t\t\t\t{ size: 3400000, scale: 1.0, label: 'moon-sized (3,400 Km)' },\n\t\t\t\t{ size: 12000000, scale: 1.0, label: 'planet-sized (12,000 km)' },\n\t\t\t\t{ size: 1400000000, scale: 1.0, label: 'sun-sized (1,400,000 km)' },\n\t\t\t\t{ size: 7.47e12, scale: 1.0, label: 'solar system-sized (50Au)' },\n\t\t\t\t{ size: 9.4605284e15, scale: 1.0, label: 'gargantuan (1 light year)' },\n\t\t\t\t{ size: 3.08567758e16, scale: 1.0, label: 'ludicrous (1 parsec)' },\n\t\t\t\t{ size: 1e19, scale: 1.0, label: 'mind boggling (1000 light years)' }\n\t\t\t];\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tconst loader = new FontLoader();\n\t\t\t\tloader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) {\n\n\t\t\t\t\tconst scene = initScene( font );\n\n\t\t\t\t\t// Initialize two copies of the same scene, one with normal z-buffer and one with logarithmic z-buffer\n\t\t\t\t\tobjects.normal = initView( scene, 'normal', false );\n\t\t\t\t\tobjects.logzbuf = initView( scene, 'logzbuf', true );\n\n\t\t\t\t\tanimate();\n\n\t\t\t\t} );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t// Resize border allows the user to easily compare effects of logarithmic depth buffer over the whole scene\n\t\t\t\tborder = document.getElementById( 'renderer_border' );\n\t\t\t\tborder.addEventListener( 'pointerdown', onBorderPointerDown );\n\n\t\t\t\twindow.addEventListener( 'mousemove', onMouseMove );\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\twindow.addEventListener( 'wheel', onMouseWheel );\n\n\t\t\t}\n\n\t\t\tfunction initView( scene, name, logDepthBuf ) {\n\n\t\t\t\tconst framecontainer = document.getElementById( 'container_' + name );\n\n\t\t\t\tconst camera = new THREE.PerspectiveCamera( 50, screensplit * SCREEN_WIDTH / SCREEN_HEIGHT, NEAR, FAR );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tconst renderer = new THREE.WebGLRenderer( { antialias: true, logarithmicDepthBuffer: logDepthBuf } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( SCREEN_WIDTH / 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.domElement.style.position = 'relative';\n\t\t\t\trenderer.domElement.id = 'renderer_' + name;\n\t\t\t\tframecontainer.appendChild( renderer.domElement );\n\n\t\t\t\treturn { container: framecontainer, renderer: renderer, scene: scene, camera: camera };\n\n\t\t\t}\n\n\t\t\tfunction initScene( font ) {\n\n\t\t\t\tconst scene = new THREE.Scene();\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x777777 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 100, 100, 100 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst materialargs = {\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\tspecular: 0x050505,\n\t\t\t\t\tshininess: 50,\n\t\t\t\t\temissive: 0x000000\n\t\t\t\t};\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 0.5, 24, 12 );\n\n\t\t\t\tfor ( let i = 0; i < labeldata.length; i ++ ) {\n\n\t\t\t\t\tconst scale = labeldata[ i ].scale || 1;\n\n\t\t\t\t\tconst labelgeo = new TextGeometry( labeldata[ i ].label, {\n\t\t\t\t\t\tfont: font,\n\t\t\t\t\t\tsize: labeldata[ i ].size,\n\t\t\t\t\t\tdepth: labeldata[ i ].size / 2\n\t\t\t\t\t} );\n\n\t\t\t\t\tlabelgeo.computeBoundingSphere();\n\n\t\t\t\t\t// center text\n\t\t\t\t\tlabelgeo.translate( - labelgeo.boundingSphere.radius, 0, 0 );\n\n\t\t\t\t\tmaterialargs.color = new THREE.Color().setHSL( Math.random(), 0.5, 0.5 );\n\n\t\t\t\t\tconst material = new THREE.MeshPhongMaterial( materialargs );\n\n\t\t\t\t\tconst group = new THREE.Group();\n\t\t\t\t\tgroup.position.z = - labeldata[ i ].size * scale;\n\t\t\t\t\tscene.add( group );\n\n\t\t\t\t\tconst textmesh = new THREE.Mesh( labelgeo, material );\n\t\t\t\t\ttextmesh.scale.set( scale, scale, scale );\n\t\t\t\t\ttextmesh.position.z = - labeldata[ i ].size * scale;\n\t\t\t\t\ttextmesh.position.y = labeldata[ i ].size / 4 * scale;\n\t\t\t\t\tgroup.add( textmesh );\n\n\t\t\t\t\tconst dotmesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tdotmesh.position.y = - labeldata[ i ].size / 4 * scale;\n\t\t\t\t\tdotmesh.scale.multiplyScalar( labeldata[ i ].size * scale );\n\t\t\t\t\tgroup.add( dotmesh );\n\n\t\t\t\t}\n\n\t\t\t\treturn scene;\n\n\t\t\t}\n\n\t\t\tfunction updateRendererSizes() {\n\n\t\t\t\t// Recalculate size for both renderers when screen size or split location changes\n\n\t\t\t\tSCREEN_WIDTH = window.innerWidth;\n\t\t\t\tSCREEN_HEIGHT = window.innerHeight;\n\n\t\t\t\tscreensplit_right = 1 - screensplit;\n\n\t\t\t\tobjects.normal.renderer.setSize( screensplit * SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\tobjects.normal.camera.aspect = screensplit * SCREEN_WIDTH / SCREEN_HEIGHT;\n\t\t\t\tobjects.normal.camera.updateProjectionMatrix();\n\t\t\t\tobjects.normal.camera.setViewOffset( SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH * screensplit, SCREEN_HEIGHT );\n\t\t\t\tobjects.normal.container.style.width = ( screensplit * 100 ) + '%';\n\n\t\t\t\tobjects.logzbuf.renderer.setSize( screensplit_right * SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\tobjects.logzbuf.camera.aspect = screensplit_right * SCREEN_WIDTH / SCREEN_HEIGHT;\n\t\t\t\tobjects.logzbuf.camera.updateProjectionMatrix();\n\t\t\t\tobjects.logzbuf.camera.setViewOffset( SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_WIDTH * screensplit, 0, SCREEN_WIDTH * screensplit_right, SCREEN_HEIGHT );\n\t\t\t\tobjects.logzbuf.container.style.width = ( screensplit_right * 100 ) + '%';\n\n\t\t\t\tborder.style.left = ( screensplit * 100 ) + '%';\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trequestAnimationFrame( animate );\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\t// Put some limits on zooming\n\t\t\t\tconst minzoom = labeldata[ 0 ].size * labeldata[ 0 ].scale * 1;\n\t\t\t\tconst maxzoom = labeldata[ labeldata.length - 1 ].size * labeldata[ labeldata.length - 1 ].scale * 100;\n\t\t\t\tlet damping = ( Math.abs( zoomspeed ) > minzoomspeed ? .95 : 1.0 );\n\n\t\t\t\t// Zoom out faster the further out you go\n\t\t\t\tconst zoom = THREE.MathUtils.clamp( Math.pow( Math.E, zoompos ), minzoom, maxzoom );\n\t\t\t\tzoompos = Math.log( zoom );\n\n\t\t\t\t// Slow down quickly at the zoom limits\n\t\t\t\tif ( ( zoom == minzoom && zoomspeed < 0 ) || ( zoom == maxzoom && zoomspeed > 0 ) ) {\n\n\t\t\t\t\tdamping = .85;\n\n\t\t\t\t}\n\n\t\t\t\tzoompos += zoomspeed;\n\t\t\t\tzoomspeed *= damping;\n\n\t\t\t\tobjects.normal.camera.position.x = Math.sin( .5 * Math.PI * ( mouse[ 0 ] - .5 ) ) * zoom;\n\t\t\t\tobjects.normal.camera.position.y = Math.sin( .25 * Math.PI * ( mouse[ 1 ] - .5 ) ) * zoom;\n\t\t\t\tobjects.normal.camera.position.z = Math.cos( .5 * Math.PI * ( mouse[ 0 ] - .5 ) ) * zoom;\n\t\t\t\tobjects.normal.camera.lookAt( objects.normal.scene.position );\n\n\t\t\t\t// Clone camera settings across both scenes\n\t\t\t\tobjects.logzbuf.camera.position.copy( objects.normal.camera.position );\n\t\t\t\tobjects.logzbuf.camera.quaternion.copy( objects.normal.camera.quaternion );\n\n\t\t\t\t// Update renderer sizes if the split has changed\n\t\t\t\tif ( screensplit_right != 1 - screensplit ) {\n\n\t\t\t\t\tupdateRendererSizes();\n\n\t\t\t\t}\n\n\t\t\t\tobjects.normal.renderer.render( objects.normal.scene, objects.normal.camera );\n\t\t\t\tobjects.logzbuf.renderer.render( objects.logzbuf.scene, objects.logzbuf.camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tupdateRendererSizes();\n\n\t\t\t}\n\n\t\t\tfunction onBorderPointerDown() {\n\n\t\t\t\t// activate draggable window resizing bar\n\t\t\t\twindow.addEventListener( 'pointermove', onBorderPointerMove );\n\t\t\t\twindow.addEventListener( 'pointerup', onBorderPointerUp );\n\n\t\t\t}\n\n\t\t\tfunction onBorderPointerMove( ev ) {\n\n\t\t\t\tscreensplit = Math.max( 0, Math.min( 1, ev.clientX / window.innerWidth ) );\n\n\t\t\t}\n\n\t\t\tfunction onBorderPointerUp() {\n\n\t\t\t\twindow.removeEventListener( 'pointermove', onBorderPointerMove );\n\t\t\t\twindow.removeEventListener( 'pointerup', onBorderPointerUp );\n\n\t\t\t}\n\n\t\t\tfunction onMouseMove( ev ) {\n\n\t\t\t\tmouse[ 0 ] = ev.clientX / window.innerWidth;\n\t\t\t\tmouse[ 1 ] = ev.clientY / window.innerHeight;\n\n\t\t\t}\n\n\t\t\tfunction onMouseWheel( ev ) {\n\n\t\t\t\tconst amount = ev.deltaY;\n\t\t\t\tif ( amount === 0 ) return;\n\t\t\t\tconst dir = amount / Math.abs( amount );\n\t\t\t\tzoomspeed = dir / 10;\n\n\t\t\t\t// Slow down default zoom speed after user starts zooming, to give them more control\n\t\t\t\tminzoomspeed = 0.001;\n\n\t\t\t}"
  },
  {
    "title": "three.js webgl - clipping planes",
    "tags": [
      "threejs",
      "webgl",
      "clipping",
      "planes"
    ],
    "description": "Example of three.js webgl - clipping planes",
    "code": "import * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer, startTime, object, stats;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 36, window.innerWidth / window.innerHeight, 0.25, 16 );\n\n\t\t\t\tcamera.position.set( 0, 1.3, 3 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// Lights\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xcccccc ) );\n\n\t\t\t\tconst spotLight = new THREE.SpotLight( 0xffffff, 60 );\n\t\t\t\tspotLight.angle = Math.PI / 5;\n\t\t\t\tspotLight.penumbra = 0.2;\n\t\t\t\tspotLight.position.set( 2, 3, 3 );\n\t\t\t\tspotLight.castShadow = true;\n\t\t\t\tspotLight.shadow.camera.near = 3;\n\t\t\t\tspotLight.shadow.camera.far = 10;\n\t\t\t\tspotLight.shadow.mapSize.width = 1024;\n\t\t\t\tspotLight.shadow.mapSize.height = 1024;\n\t\t\t\tscene.add( spotLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0x55505a, 3 );\n\t\t\t\tdirLight.position.set( 0, 3, 0 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.near = 1;\n\t\t\t\tdirLight.shadow.camera.far = 10;\n\n\t\t\t\tdirLight.shadow.camera.right = 1;\n\t\t\t\tdirLight.shadow.camera.left = - 1;\n\t\t\t\tdirLight.shadow.camera.top\t= 1;\n\t\t\t\tdirLight.shadow.camera.bottom = - 1;\n\n\t\t\t\tdirLight.shadow.mapSize.width = 1024;\n\t\t\t\tdirLight.shadow.mapSize.height = 1024;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// ***** Clipping planes: *****\n\n\t\t\t\tconst localPlane = new THREE.Plane( new THREE.Vector3( 0, - 1, 0 ), 0.8 );\n\t\t\t\tconst globalPlane = new THREE.Plane( new THREE.Vector3( - 1, 0, 0 ), 0.1 );\n\n\t\t\t\t// Geometry\n\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0x80ee10,\n\t\t\t\t\tshininess: 100,\n\t\t\t\t\tside: THREE.DoubleSide,\n\n\t\t\t\t\t// ***** Clipping setup (material): *****\n\t\t\t\t\tclippingPlanes: [ localPlane ],\n\t\t\t\t\tclipShadows: true,\n\n\t\t\t\t\talphaToCoverage: true,\n\n\t\t\t\t} );\n\n\t\t\t\tconst geometry = new THREE.TorusKnotGeometry( 0.4, 0.08, 95, 20 );\n\n\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\t\t\t\tobject.castShadow = true;\n\t\t\t\tscene.add( object );\n\n\t\t\t\tconst ground = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 9, 9, 1, 1 ),\n\t\t\t\t\tnew THREE.MeshPhongMaterial( { color: 0xa0adaf, shininess: 150 } )\n\t\t\t\t);\n\n\t\t\t\tground.rotation.x = - Math.PI / 2; // rotates X/Y to X/Z\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tscene.add( ground );\n\n\t\t\t\t// Renderer\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// ***** Clipping setup (renderer): *****\n\t\t\t\tconst globalPlanes = [ globalPlane ],\n\t\t\t\t\tEmpty = Object.freeze( [] );\n\t\t\t\trenderer.clippingPlanes = Empty; // GUI sets it to globalPlanes\n\t\t\t\trenderer.localClippingEnabled = true;\n\n\t\t\t\t// Stats\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t// Controls\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 1, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst gui = new GUI(),\n\t\t\t\t\tprops = {\n\t\t\t\t\t\talphaToCoverage: true,\n\t\t\t\t\t},\n\t\t\t\t\tfolderLocal = gui.addFolder( 'Local Clipping' ),\n\t\t\t\t\tpropsLocal = {\n\n\t\t\t\t\t\tget 'Enabled'() {\n\n\t\t\t\t\t\t\treturn renderer.localClippingEnabled;\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset 'Enabled'( v ) {\n\n\t\t\t\t\t\t\trenderer.localClippingEnabled = v;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tget 'Shadows'() {\n\n\t\t\t\t\t\t\treturn material.clipShadows;\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset 'Shadows'( v ) {\n\n\t\t\t\t\t\t\tmaterial.clipShadows = v;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tget 'Plane'() {\n\n\t\t\t\t\t\t\treturn localPlane.constant;\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset 'Plane'( v ) {\n\n\t\t\t\t\t\t\tlocalPlane.constant = v;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t},\n\t\t\t\t\tfolderGlobal = gui.addFolder( 'Global Clipping' ),\n\t\t\t\t\tpropsGlobal = {\n\n\t\t\t\t\t\tget 'Enabled'() {\n\n\t\t\t\t\t\t\treturn renderer.clippingPlanes !== Empty;\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset 'Enabled'( v ) {\n\n\t\t\t\t\t\t\trenderer.clippingPlanes = v ? globalPlanes : Empty;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tget 'Plane'() {\n\n\t\t\t\t\t\t\treturn globalPlane.constant;\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset 'Plane'( v ) {\n\n\t\t\t\t\t\t\tglobalPlane.constant = v;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t};\n\n\t\t\t\tgui.add( props, 'alphaToCoverage' ).onChange( function ( value ) {\n\n\t\t\t\t\tground.material.alphaToCoverage = value;\n\t\t\t\t\tground.material.needsUpdate = true;\n\n\t\t\t\t\tmaterial.alphaToCoverage = value;\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} );\n\t\t\t\tfolderLocal.add( propsLocal, 'Enabled' );\n\t\t\t\tfolderLocal.add( propsLocal, 'Shadows' );\n\t\t\t\tfolderLocal.add( propsLocal, 'Plane', 0.3, 1.25 );\n\n\t\t\t\tfolderGlobal.add( propsGlobal, 'Enabled' );\n\t\t\t\tfolderGlobal.add( propsGlobal, 'Plane', - 0.4, 3 );\n\n\t\t\t\t// Start\n\n\t\t\t\tstartTime = Date.now();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst currentTime = Date.now();\n\t\t\t\tconst time = ( currentTime - startTime ) / 1000;\n\n\t\t\t\tobject.position.y = 0.8;\n\t\t\t\tobject.rotation.x = time * 0.5;\n\t\t\t\tobject.rotation.y = time * 0.2;\n\t\t\t\tobject.scale.setScalar( Math.cos( time ) * 0.125 + 0.875 );\n\n\t\t\t\tstats.begin();\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\tstats.end();\n\n\t\t\t}"
  }
]